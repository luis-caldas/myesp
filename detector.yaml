#########
# Setup #
#########

substitutions:
  friendly: "Detector"
  name: detector
  # Tune
  tune: "siren:d=8,o=7,b=200:d,e,d,e,d,e,d,e"
  # Voltage Divider
  divider: "2"
  input_voltage: "3.3"
  # ADC
  accuracy: "2"
  charger_voltage_cut: "4"
  # Sensors
  co_load: "10000.0"
  co_fresh: "100000.0"
  smoke_load: "4700.0"
  smoke_fresh: "60000.0"
  # Limits
  smoke_limit: "30"
  co2_limit: "2000"
  co_limit: "20"
  # Updates
  sensors_update: 10s
  screen_update: 5s
  # Timeouts
  display_timeout: 10s
  siren_timeout: 1min
  # Intervals
  siren_interval: 10s

esphome:
  name: $name
  friendly_name: $friendly
  name_add_mac_suffix: true

esp32:
  board: esp32dev

############
# Packages #
############

packages:
  # Connection
  connection: !include common/connection.yaml
  # Extras
  extras: !include common/extras.yaml
  extras-32: !include common/extras-32.yaml

###############
# Connections #
###############

spi:
  clk_pin: GPIO18   # E  - #6
  mosi_pin: GPIO23  # RW - #5
  interface: spi2

i2c:
  sda: GPIO21  # SDA
  scl: GPIO22  # SCL
  scan: true
  id: bus_a

time:
  - platform: homeassistant
    id: esptime

##########
# States #
##########

globals:
  - id: previous_alert
    type: bool
    restore_value: no
    initial_value: 'false'

binary_sensor:

  # Anomaly Alert
  - platform: template
    name: Alert
    icon: "mdi:alert-box"
    id: alert_state
    # Conglomerate all sensors into one binary limit alert
    condition:
      any:
        - sensor.in_range:
            id: sensor_co2
            above: $co2_limit
        - sensor.in_range:
            id: co_ppm
            above: $co_limit
        - sensor.in_range:
            id: smoke_percentage
            above: $smoke_limit
    # Update screen on start
    on_press:
      - component.update: display_lcd
    # Reset
    on_release:
      lambda: |-
        id(previous_alert) = false;

  # Buzzer state
  - platform: template
    name: Siren
    icon: "mdi:access-point"
    id: buzzer_state
    internal: true
    # Only enabled when no previous alert
    lambda: |-
      if (!id(previous_alert) && id(alert_state).state) {
        id(previous_alert) = true;
        return true;
      } else if (!id(previous_alert) && !id(alert_state).state) {
        return false;
      } else {
        return {};
      }
    # Start the noise
    on_press:
      # Wait for period then turn it off
      - delay: $siren_timeout
      - binary_sensor.template.publish:
          id: buzzer_state
          state: OFF
    # Cut off siren and update display
    on_release:
      - rtttl.stop
      - component.update: display_lcd

  # Physical Button
  - platform: gpio
    name: Button
    pin:
      number: GPIO4
      mode: INPUT_PULLUP
    internal: true
    on_press:
      then:
        if:
          condition:
            binary_sensor.is_on: buzzer_state
          then:
            binary_sensor.template.publish:
              id: buzzer_state
              state: OFF
          else:
            light.turn_on: backlight

  # Charging
  - platform: template
    name: Charging
    icon: mdi:lightning-bolt
    id: charging
    lambda: |-
      if (id(input_voltage).state > $charger_voltage_cut) {
        return true;
      } else {
        return false;
      }

button:

  # Virtual Button
  - platform: template
    name: Silence
    id: silence
    # Optional variables:
    icon: "mdi:ear-hearing-off"
    on_press:
      then:
        if:
          condition:
            binary_sensor.is_on: buzzer_state
          then:
            binary_sensor.template.publish:
              id: buzzer_state
              state: OFF

##############
# Automation #
##############

# Example configuration entry
interval:
  - interval: $siren_interval
    then:
      if:
        condition:
          binary_sensor.is_on: buzzer_state
        then:
          rtttl.play: $tune

#############
# Backlight #
#############

light:
  - platform: monochromatic
    output: out_back
    id: backlight
    name: "Backlight"
    restore_mode: ALWAYS_ON
    initial_state:
      brightness: 100%
    default_transition_length: 0.5s
    on_turn_on:
      - delay: $display_timeout
      - light.turn_off: backlight

output:

  - platform: ledc
    pin: GPIO16
    id: out_back

##########
# Buzzer #
##########

  - platform: ledc
    pin: GPIO27
    id: buzzer

rtttl:
  output: buzzer

api:
  actions:
    - action: play_buzzer
      variables:
        song_string: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_string;'


##########
# Assets #
##########

image:
  # Smoke Indicator
  - file: mdi:smoke
    id: smoke_image
    type: BINARY
    resize: 12x12
  # Humidity Indicator
  - file: mdi:water
    id: water_image
    type: BINARY
    resize: 12x12
  # Alert Box
  - file: mdi:exclamation-thick
    id: alert_image
    type: BINARY
    invert_alpha: true
    resize: 20x20
  # Sound Indicator
  - file: mdi:access-point
    id: sound_image
    type: BINARY
    invert_alpha: true
    resize: 16x16

font:
  # ### Bitmap Fonts ### #
  # Small
  - file: "assets/spleen-5x8.pcf"
    id: font_small
    glyphs: ' 0123456789/'
  # Normal
  - file: "assets/spleen-6x12.pcf"
    id: font_normal
    glyphs: ' 0123456789/:-.°CO'
  # Information
  - file: "assets/spleen-8x16.pcf"
    id: font_info
    glyphs: ' 0123456789'
  # Big
  - file: "assets/spleen-16x32.pcf"
    id: font_big
    glyphs: ' 0123456789'

###########
# Display #
###########

display:

  # Connections
  # #01	GND	- GND
  # #02	VCC	- VCC (5V)
  # #03 V0  - Not Needed (Regulated By Potentiometer Under Board)
  # #04	RS	- Any GPIO || CS (GPIO5)
  # #05	R/W	- MOSI (GPIO23)
  # #06	E	  - CLK (GPIO18)
  # #15	PSB	- GND (Enable SPI Mode)
  # #19	BLA	- Backlight
  # #20	BLK	- GND

  - platform: st7920
    rotation: 90
    update_interval: $screen_update
    cs_pin:
      number: GPIO17  # RS - #4
      inverted: true
    width: 128
    height: 64
    id: display_lcd
    lambda: |-
      //=========//
      // Battery //
      //=========//

      // Charging
      if (id(charging).state) {
        // Bolt
        it.line(26, 5, 23, 8);
        it.line(23, 8, 28, 8);
        it.line(28, 8, 25, 11);
      }

      // Sizing
      int battery_height = 9;
      int battery_width = 18;

      // Calculation
      int indication = ((float) id(battery_percentage).state / 100) * battery_width;

      // Print Battery
      it.rectangle(2, 4, battery_width, battery_height);
      it.filled_rectangle(2, 4, indication, battery_height);

      // Tip
      it.line(21, 5, 21, 11);

      //======//
      // Time //
      //======//

      // Print
      it.strftime(64, 0, id(font_normal), TextAlign::TOP_RIGHT, "%H:%M", id(esptime).now());
      it.strftime(64, 12, id(font_small), TextAlign::TOP_RIGHT, "%d/%m", id(esptime).now());

      //=======//
      // Alert //
      //=======//

      // Buzzer -> Alerts
      if (id(alert_state).state) {

        // Bounding Box
        it.filled_rectangle(0, 23, 64, 20);

        // Alert Image
        it.image(22, 23, id(alert_image));

        // Buzzer Indicator
        if (id(buzzer_state).state) {
          it.image(0, 25, id(sound_image));
          it.image(48, 25, id(sound_image));
        }

      }

      //=====//
      // CO2 //
      //=====//

      int co2_height = 46;

      float co2_state = id(sensor_co2).state;
      co2_state = isnan(co2_state) ? 0 : co2_state;
      it.printf(4, co2_height, id(font_info), "%4.0f", co2_state);
      it.printf(46, co2_height + 1, id(font_normal), "CO2");

      //====//
      // CO //
      //====//

      int co_height = 60;

      float co_state = id(co_ppm).state;
      co_state = isnan(co_state) ? 0 : co_state;
      it.printf(4, co_height, id(font_info), "%4.0f", co_state);
      it.printf(46, co_height + 1, id(font_normal), " CO");

      //========//
      // Visual //
      //========//

      // Globals
      int half_icon = 6;

      int rectangle_height = 12;
      int rectangle_half_height = 6;
      int rectangle_width = 50;

      int width_start = 14;

      // Variables
      int height = 0;
      int filled = 0;
      int height_start = 0;

      //==========//
      // Humidity //
      //==========//

      height = 82;

      // Calculate
      filled = 0;
      float state_humidity = id(sensor_humidity).state;
      if (state_humidity == state_humidity)
        filled = state_humidity / 100 * rectangle_width;

      height_start = height - rectangle_half_height;

      // Shapes
      it.rectangle(width_start, height_start, rectangle_width, rectangle_height);
      it.filled_rectangle(width_start, height_start, filled, rectangle_height);

      // Icon
      it.image(0, height - half_icon, id(water_image));

      //=======//
      // Smoke //
      //=======//

      height = 98;

      // Calculate
      filled = 0;
      float state_smoke = id(smoke_percentage).state;
      if (state_smoke == state_smoke)
        filled = state_smoke / 100 * rectangle_width;

      height_start = height - rectangle_half_height;

      // Shapes
      it.rectangle(width_start, height_start, rectangle_width, rectangle_height);
      it.filled_rectangle(width_start, height_start, filled, rectangle_height);

      // Icon
      it.image(0, height - half_icon, id(smoke_image));

      //=============//
      // Temperature //
      //=============//

      // Calculate
      float state_whole = id(sensor_temperature).state;
      state_whole = isnan(state_whole) ? 0 : state_whole;
      int state_decimal = 0;
      if (state_whole == state_whole)
        state_decimal = (int)((state_whole - (int) state_whole) * 100) % 100;

      // Display
      it.printf(8, 102, id(font_big), "%2.0f", state_whole);
      it.printf(40, 107, id(font_normal), ".%02d", state_decimal);
      it.printf(46, 119, id(font_normal), "°C", state_decimal);

###########
# Sensors #
###########

sensor:

  # SCD41
  - platform: scd4x
    update_interval: $sensors_update
    co2:
      name: "Carbon Dioxide"
      id: sensor_co2
    temperature:
      name: "Temperature"
      id: sensor_temperature
    humidity:
      name: "Humidity"
      id: sensor_humidity

  # Smoke
  - platform: adc
    pin: GPIO34
    id: smoke_voltage
    name: "Smoke Voltage"
    internal: true
    unit_of_measurement: "V"
    update_interval: $sensors_update
    attenuation: auto
    on_value:
      then:
        - component.update: smoke_ratio

  - platform: template
    id: smoke_ratio
    name: "Smoke Ratio"
    internal: true
    unit_of_measurement: "Rs/R0"
    update_interval: never
    lambda: |-
      // Reference voltage
      float now_v = id(smoke_voltage).state;

      // Safety
      if (now_v == 0) return 0;

      // Voltage Divider
      float r_s = $smoke_load * ($input_voltage - now_v) / now_v;

      // Ratio
      return r_s / $smoke_fresh;
    on_value:
      then:
        - component.update: smoke_ppm

  - platform: template
    id: smoke_ppm
    name: "Smoke PPM"
    internal: true
    unit_of_measurement: "ppm"
    update_interval: never
    lambda: |-
      return id(smoke_ratio).state;
    filters:
      - calibrate_linear:
          method: exact
          datapoints:
            - 0.0589 -> 1672.54
            - 0.065 -> 998.41
            - 0.07 -> 506.75
            - 0.078 -> 200.66
            - 0.08 -> 100.57
            - 0.102 -> 50.26
            - 0.108 -> 40.01
            - 0.12 -> 30.13
            - 0.13 -> 20.12
            - 0.17 -> 10.01
            - 0.23 -> 4.99
            - 0.26 -> 3.99
            - 0.33 -> 3.00
            - 0.43 -> 2.01
            - 0.585 -> 1.02
            - 0.728 -> 0.43
            - 1 -> 0
    on_value:
      then:
        - component.update: smoke_percentage

  - platform: template
    id: smoke_percentage
    name: "Smoke"
    icon: mdi:smoke
    unit_of_measurement: "%"
    update_interval: never
    accuracy_decimals: $accuracy
    lambda: return id(smoke_ppm).state;
    filters:
      - calibrate_linear:
          datapoints:
            - 0 -> 0
            - 1000 -> 100
      - lambda: |-
          if (x <= 100) {
            return x;
          } else {
            return 100;
          }
          if (x <= 0) {
            return 0;
          }

  # CO
  - platform: adc
    pin: GPIO35
    id: co_voltage
    name: "Carbon Monoxide Voltage"
    internal: true
    unit_of_measurement: "V"
    update_interval: $sensors_update
    attenuation: auto
    on_value:
      then:
        - component.update: co_ratio

  - platform: template
    id: co_ratio
    name: "Carbon Monoxide Ratio"
    internal: true
    unit_of_measurement: "Rs/R0"
    update_interval: never
    lambda: |-
      // Reference voltage
      float now_v = id(co_voltage).state;

      // Safety
      if (now_v == 0) return 0;

      // Rs Voltage Divider
      float r_s = $co_load * ($input_voltage - now_v) / now_v;

      return r_s / $co_fresh;
    on_value:
      then:
        - component.update: co_ppm

  - platform: template
    id: co_ppm
    name: "Carbon Monoxide"
    icon: mdi:molecule-co
    unit_of_measurement: "ppm"
    update_interval: never
    lambda: |-
      return id(co_ratio).state;
    filters:
      - calibrate_linear:
          method: exact
          datapoints:
          - 0.11 -> 998.24
          - 0.12 -> 502.67
          - 0.14 -> 149.72
          - 0.17 -> 98.76
          - 0.21 -> 49.95
          - 0.28 -> 20.12
          - 0.40 -> 10.10
          - 0.53 -> 4.96
          - 0.76 -> 1.01
          - 0.91 -> 0.37
          - 1.00 -> 0.00

#########
# Power #
#########

  # Input
  - platform: adc
    pin: GPIO36
    id: input_voltage
    name: "Input Voltage"
    internal: true
    attenuation: auto
    accuracy_decimals: $accuracy
    filters:
      - multiply: $divider
    unit_of_measurement: "V"
    update_interval: $sensors_update

  # Battery
  - platform: adc
    id: battery_voltage
    name: "Battery Voltage"
    pin: GPIO39
    internal: true
    attenuation: auto
    filters:
      - multiply: $divider
    update_interval: $sensors_update
    on_value:
      then:
        - component.update: battery_percentage

  - platform: template
    id: battery_percentage
    name: "Battery"
    icon: mdi:battery
    accuracy_decimals: 0
    unit_of_measurement: "%"
    lambda: return id(battery_voltage).state;
    filters:
      - calibrate_linear:
         method: exact
         datapoints:
          - 0.00 -> 0.0
          - 3.30 -> 1.0
          - 3.39 -> 10.0
          - 3.75 -> 50.0
          - 4.11 -> 90.0
          - 4.20 -> 100.0
      - lambda: |-
          if (x <= 100) {
            return x;
          } else {
            return 100;
          }
          if (x < 0) {
            return 0;
          }
